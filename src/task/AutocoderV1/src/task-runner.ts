import * as tl from 'azure-pipelines-task-lib/task';
import { WorkItemService } from './work-item';
import { AgentExecutor } from './agent-executor';
import { GitOperations } from './git-operations';
import { PullRequestService } from './pull-request';
import * as fs from 'fs';
import * as path from 'path';

export interface TaskInputs {
    workItemId?: string;
    userPrompt?: string;
    agentType: 'copilot' | 'claude';
    containerImage?: string;
    systemPrompt?: string;
    createPullRequest: boolean;
    targetBranch: string;
    sourceBranchPrefix: string;
    additionalContext?: string;
}

export class TaskRunner {
    private workItemService: WorkItemService;
    private agentExecutor: AgentExecutor;
    private gitOperations: GitOperations;
    private pullRequestService: PullRequestService;

    constructor() {
        this.workItemService = new WorkItemService();
        this.agentExecutor = new AgentExecutor();
        this.gitOperations = new GitOperations();
        this.pullRequestService = new PullRequestService();
    }

    async run(): Promise<void> {
        tl.debug('Starting Autocoder task');

        // Get and validate inputs
        const inputs = this.getInputs();
        this.validateInputs(inputs);

        tl.debug(`Agent type: ${inputs.agentType}`);
        tl.debug(`Create PR: ${inputs.createPullRequest}`);
        tl.debug(`Target branch: ${inputs.targetBranch}`);

        // Fetch work item details if provided
        let workItemDetails = '';
        if (inputs.workItemId) {
            tl.debug(`Fetching work item: ${inputs.workItemId}`);
            workItemDetails = await this.workItemService.getWorkItemDetails(inputs.workItemId);
        }

        // Prepare the prompt
        const systemPrompt = await this.prepareSystemPrompt(
            inputs.systemPrompt,
            workItemDetails,
            inputs.userPrompt,
            inputs.additionalContext
        );

        // Generate branch name
        const branchName = this.generateBranchName(inputs.sourceBranchPrefix, inputs.workItemId);
        tl.debug(`Generated branch name: ${branchName}`);

        // Create and checkout new branch
        await this.gitOperations.createBranch(branchName, inputs.targetBranch);

        // Execute the AI agent
        tl.debug('Executing AI agent');
        await this.agentExecutor.execute({
            agentType: inputs.agentType,
            containerImage: inputs.containerImage,
            systemPrompt: systemPrompt,
            workingDirectory: tl.getVariable('Build.SourcesDirectory') || process.cwd()
        });

        // Check if there are any changes
        const hasChanges = await this.gitOperations.hasChanges();
        if (!hasChanges) {
            tl.warning('No code changes were generated by the AI agent');
            return;
        }

        // Commit changes
        const commitMessage = this.generateCommitMessage(inputs.workItemId, inputs.userPrompt);
        await this.gitOperations.commitChanges(commitMessage);

        // Push changes
        await this.gitOperations.pushBranch(branchName);

        // Create pull request if requested
        if (inputs.createPullRequest) {
            tl.debug('Creating pull request');
            const prTitle = this.generatePRTitle(inputs.workItemId, inputs.userPrompt);
            const prDescription = this.generatePRDescription(inputs.workItemId, inputs.userPrompt, inputs.agentType);
            
            const prUrl = await this.pullRequestService.createPullRequest({
                sourceBranch: branchName,
                targetBranch: inputs.targetBranch,
                title: prTitle,
                description: prDescription,
                workItemId: inputs.workItemId
            });

            tl.setVariable('AutocoderPullRequestUrl', prUrl);
            console.log(`Pull request created: ${prUrl}`);
        }

        tl.setResult(tl.TaskResult.Succeeded, 'Autocoder task completed successfully');
    }

    private getInputs(): TaskInputs {
        return {
            workItemId: tl.getInput('workItemId', false),
            userPrompt: tl.getInput('userPrompt', false),
            agentType: tl.getInput('agentType', true) as 'copilot' | 'claude',
            containerImage: tl.getInput('containerImage', false),
            systemPrompt: tl.getInput('systemPrompt', false),
            createPullRequest: tl.getBoolInput('createPullRequest', false) ?? true,
            targetBranch: tl.getInput('targetBranch', false) || 'main',
            sourceBranchPrefix: tl.getInput('sourceBranchPrefix', false) || 'autocoder/',
            additionalContext: tl.getInput('additionalContext', false)
        };
    }

    private validateInputs(inputs: TaskInputs): void {
        if (!inputs.workItemId && !inputs.userPrompt) {
            throw new Error('Either workItemId or userPrompt must be provided');
        }

        if (!['copilot', 'claude'].includes(inputs.agentType)) {
            throw new Error(`Invalid agent type: ${inputs.agentType}. Must be 'copilot' or 'claude'`);
        }
    }

    private async prepareSystemPrompt(
        customSystemPrompt: string | undefined,
        workItemDetails: string,
        userPrompt: string | undefined,
        additionalContext: string | undefined
    ): Promise<string> {
        let systemPrompt: string;

        if (customSystemPrompt) {
            systemPrompt = customSystemPrompt;
        } else {
            // Read default system prompt
            const promptPath = path.join(__dirname, 'prompts', 'default-system-prompt.md');
            systemPrompt = fs.readFileSync(promptPath, 'utf-8');
        }

        // Replace placeholders
        systemPrompt = systemPrompt.replace('{work_item_details}', workItemDetails || 'No work item provided');
        systemPrompt = systemPrompt.replace('{user_prompt}', userPrompt || 'No additional instructions provided');

        if (additionalContext) {
            systemPrompt += `\n\nAdditional Context:\n${additionalContext}`;
        }

        return systemPrompt;
    }

    private generateBranchName(prefix: string, workItemId?: string): string {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        if (workItemId) {
            return `${prefix}wi-${workItemId}-${timestamp}`;
        }
        return `${prefix}${timestamp}`;
    }

    private generateCommitMessage(workItemId?: string, userPrompt?: string): string {
        let message = '[Autocoder] AI-generated code changes';
        if (workItemId) {
            message += ` for #${workItemId}`;
        }
        if (userPrompt) {
            // Take first 50 characters of user prompt for commit message
            const shortPrompt = userPrompt.substring(0, 50).replace(/\n/g, ' ');
            message += `: ${shortPrompt}${userPrompt.length > 50 ? '...' : ''}`;
        }
        return message;
    }

    private generatePRTitle(workItemId?: string, userPrompt?: string): string {
        let title = '[Autocoder]';
        if (workItemId) {
            title += ` #${workItemId}:`;
        }
        if (userPrompt) {
            const shortPrompt = userPrompt.substring(0, 60).replace(/\n/g, ' ');
            title += ` ${shortPrompt}${userPrompt.length > 60 ? '...' : ''}`;
        } else {
            title += ' AI-generated code changes';
        }
        return title;
    }

    private generatePRDescription(workItemId?: string, userPrompt?: string, agentType?: string): string {
        let description = '## ü§ñ AI-Generated Pull Request\n\n';
        description += 'This pull request was automatically generated by Autocoder.\n\n';
        description += `**AI Agent:** ${agentType === 'copilot' ? 'GitHub Copilot' : 'Claude Code'}\n\n`;

        if (workItemId) {
            description += `**Work Item:** #${workItemId}\n\n`;
        }

        if (userPrompt) {
            description += `**Instructions:**\n${userPrompt}\n\n`;
        }

        description += '---\n\n';
        description += '‚ö†Ô∏è **Note:** This code was generated by AI and requires human review before merging.\n';
        description += 'Please verify the changes carefully and ensure they meet your quality standards.\n';

        return description;
    }
}
